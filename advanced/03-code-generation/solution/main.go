package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

type StructInfo struct {
	Name   string
	Fields []FieldInfo
}

type FieldInfo struct {
	Name string
	Type string
	Tag  string
}

func ParseStructs(filename string) ([]StructInfo, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var structs []StructInfo

	ast.Inspect(node, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			return true
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			structInfo := StructInfo{
				Name:   typeSpec.Name.Name,
				Fields: []FieldInfo{},
			}

			for _, field := range structType.Fields.List {
				for _, name := range field.Names {
					fieldInfo := FieldInfo{
						Name: name.Name,
						Type: exprToString(field.Type),
					}
					if field.Tag != nil {
						fieldInfo.Tag = field.Tag.Value
					}
					structInfo.Fields = append(structInfo.Fields, fieldInfo)
				}
			}

			structs = append(structs, structInfo)
		}

		return true
	})

	return structs, nil
}

func exprToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + exprToString(t.X)
	case *ast.ArrayType:
		return "[]" + exprToString(t.Elt)
	case *ast.SelectorExpr:
		return exprToString(t.X) + "." + t.Sel.Name
	default:
		return "interface{}"
	}
}

var builderTemplate = `
type {{.Name}}Builder struct {
    {{range .Fields}}{{.Name}} {{.Type}}
    {{end}}
}

func New{{.Name}}Builder() *{{.Name}}Builder {
    return &{{.Name}}Builder{}
}

{{range .Fields}}
func (b *{{.Name}}Builder) {{.Name}}(val {{.Type}}) *{{.Name}}Builder {
    b.{{.Name}} = val
    return b
}
{{end}}

func (b *{{.Name}}Builder) Build() {{.Name}} {
    return {{.Name}}{
        {{range .Fields}}{{.Name}}: b.{{.Name}},
        {{end}}
    }
}
`

func GenerateBuilder(s StructInfo) (string, error) {
	tmpl, err := template.New("builder").Parse(builderTemplate)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, s); err != nil {
		return "", err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.String(), nil // Return unformatted if formatting fails
	}

	return string(formatted), nil
}

var validationTemplate = `
func ({{.ShortName}} {{.Name}}) Validate() []error {
    var errors []error
    {{range .Fields}}{{if .HasValidation}}
    // Validate {{.Name}}
    {{end}}{{end}}
    return errors
}
`

func GenerateValidation(s StructInfo) (string, error) {
	data := struct {
		Name      string
		ShortName string
		Fields    []FieldInfo
	}{
		Name:      s.Name,
		ShortName: strings.ToLower(string(s.Name[0])),
		Fields:    s.Fields,
	}

	var buf bytes.Buffer
	buf.WriteString(fmt.Sprintf("func (%s %s) Validate() []error {\n", data.ShortName, s.Name))
	buf.WriteString("    var errors []error\n")
	buf.WriteString("    return errors\n")
	buf.WriteString("}\n")

	return buf.String(), nil
}

func GenerateString(s StructInfo) (string, error) {
	var buf bytes.Buffer
	shortName := strings.ToLower(string(s.Name[0]))

	buf.WriteString(fmt.Sprintf("func (%s %s) String() string {\n", shortName, s.Name))
	buf.WriteString("    return fmt.Sprintf(\"" + s.Name + "{")

	parts := []string{}
	for _, f := range s.Fields {
		parts = append(parts, f.Name+": %v")
	}
	buf.WriteString(strings.Join(parts, ", "))
	buf.WriteString("}\",\n        ")

	fieldRefs := []string{}
	for _, f := range s.Fields {
		fieldRefs = append(fieldRefs, shortName+"."+f.Name)
	}
	buf.WriteString(strings.Join(fieldRefs, ", "))
	buf.WriteString(")\n}\n")

	return buf.String(), nil
}

func main() {
	inputFile := flag.String("input", "", "Input Go source file")
	outputFile := flag.String("output", "", "Output file for generated code")
	flag.Parse()

	if *inputFile == "" {
		fmt.Println("Usage: go run main.go -input=file.go -output=generated.go")
		os.Exit(1)
	}

	structs, err := ParseStructs(*inputFile)
	if err != nil {
		fmt.Printf("Error parsing file: %v\n", err)
		os.Exit(1)
	}

	var generated bytes.Buffer
	generated.WriteString("package main\n\nimport \"fmt\"\n\n")

	for _, s := range structs {
		builder, err := GenerateBuilder(s)
		if err != nil {
			fmt.Printf("Error generating builder: %v\n", err)
			continue
		}
		generated.WriteString(builder)
		generated.WriteString("\n\n")

		validation, err := GenerateValidation(s)
		if err != nil {
			fmt.Printf("Error generating validation: %v\n", err)
			continue
		}
		generated.WriteString(validation)
		generated.WriteString("\n\n")

		str, err := GenerateString(s)
		if err != nil {
			fmt.Printf("Error generating String: %v\n", err)
			continue
		}
		generated.WriteString(str)
		generated.WriteString("\n\n")
	}

	if *outputFile != "" {
		if err := os.WriteFile(*outputFile, generated.Bytes(), 0644); err != nil {
			fmt.Printf("Error writing output: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated code written to %s\n", *outputFile)
	} else {
		fmt.Println(generated.String())
	}
}
